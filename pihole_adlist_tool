#!/bin/bash

# define path to pihole's databases and temporary database
TEMP_DB="/tmp/temp.db"
PIHOLE_FTL="file:/etc/pihole/pihole-FTL.db?mode=ro"
GRAVITY="file:/etc/pihole/gravity.db?mode=ro"

#define and initialize variables
declare -i DAYS_REQUESTED
DAYS_REQUESTED=90
declare -i TIMESTAMP_REQUESTED
DATE_REQUESTED=
DATE_FIRST_QUERY=
declare -i TIMESTAMP_FIRST_QUERY
declare -i TIMESTAMP_FIRST_ANALYZED
DATE_FIRST_ANALYZED=
declare -i FTL_ID
FTL_ID=0
TOP=0
SORT=
NUM_DOMAINS_BLOCKED=
HITS_TOTAL=
SORT_ORDER=
NUM_ADLISTS=
NUM_ADLISTS_ENABLED=
NUM_GRAVITY_UNIQUE_DOMAINS=
NUM_DOMAINS_BLOCKED_CURRENT=
HITS_TOTAL_CURRENT=
BLACKLIST_GRAVITY=
UNIQUE=
NUM_TOTAL_UNIQUE_DOMAINS=

#for text formating
bold=$(tput bold)
normal=$(tput sgr0)

# help message
print_help() {
  echo "Usage: pihole_adlist_tool [options]
    
    Options:
    -d [Num]                         Consider the last [Num] days (Default: 90). Enter 0 for all-time analysis.
    -t [Num]                         Show top blocked domains. [Num] defines the number to show.
    -s [total/covered/hits/unique]   Set sorting order to total (total domains), covered (domains covered), hits (hits covered) or unique (covered unique domains) DESC. (Default sorting: id ASC)
    -u                               Show covered unique domains
    -h                               Show this help dialog
"
}

# getopts flags and assing arguments to variables

while getopts 'd:t:s:uh' flag; do
  case "${flag}" in
    d) DAYS_REQUESTED="${OPTARG}" ;;
    t) TOP="${OPTARG}" ;;
    s) SORT="${OPTARG}" ;;
    u) UNIQUE=1;;
    h) print_help
        exit 0 ;;
    *) print_help
        exit 1 ;;
  esac
done

echo
echo "${bold}*** Pihole Adlist Tool ***${normal}"
echo

# function to get the id of the query timestamp for the selected timeframe (DAYS_REQUESTED)
# if "all time" is selected, ID=1 and timestamp=first query timestamp
# otherwise calculates the timestamp, selectes the next bigger or equal timestamp in pihole-ftl.db and get corresponding id
# using id as it is as INTEGER PRIMARY KEY an alias for ROWIDs
# in case the requested time period started before the first query timestamp, show warining 

get_ftl_id () {
    TIMESTAMP_FIRST_QUERY=$(sqlite3 $PIHOLE_FTL "SELECT MIN(timestamp) FROM queries;")
    DATE_FIRST_QUERY=$(date -d @$TIMESTAMP_FIRST_QUERY +%d.%m.%Y%t%k:%M:%S)

    if [ "$DAYS_REQUESTED" = 0 ];
        then FTL_ID=1
        DATE_FIRST_ANALYZED=$DATE_FIRST_QUERY
    else

        TIMESTAMP_REQUESTED=$(date +%s)
        TIMESTAMP_REQUESTED=$TIMESTAMP_REQUESTED-86400*${DAYS_REQUESTED}
        DATE_REQUESTED=$(date -d @$TIMESTAMP_REQUESTED +%d.%m.%Y%t%k:%M:%S)
  
        if [ "$TIMESTAMP_FIRST_QUERY" -gt "$TIMESTAMP_REQUESTED" ];
            then 
                echo
                echo "${bold}Warning:${normal} You requested to analyze "${DAYS_REQUESTED}" days (since "$DATE_REQUESTED"), but oldest query is from "$DATE_FIRST_QUERY". Using this instead." 
                echo
        fi
        read FTL_ID TIMESTAMP_FIRST_ANALYZED <<<$(sqlite3 -separator " " $PIHOLE_FTL "SELECT MIN(id),timestamp FROM queries WHERE timestamp>=$TIMESTAMP_REQUESTED;")
        DATE_FIRST_ANALYZED=$(date -d @$TIMESTAMP_FIRST_ANALYZED +%d.%m.%Y%t%k:%M:%S) 
    fi

}


# get FTL_ID based on DAYS_REQUESTED
case "$DAYS_REQUESTED" in
    ''|*[0-9]*)     get_ftl_id ;;
    *) print_help
        exit 1 ;;
esac


case "$SORT" in
    total)      SORT_ORDER="total_domains DESC" ;;
    domains)    SORT_ORDER="domains_covered DESC" ;;
    hits)       SORT_ORDER="hits_covered DESC" ;;
    unique)     SORT_ORDER="unique_domains_covered DESC" ;;
    *)          SORT_ORDER="id ASC" ;;
esac

case "$TOP" in
    ''|*[0-9]*)     ;;
    *) print_help
        exit 1 ;;
esac




echo "Calculating....."
echo
echo "This might take some time - please be patient."
# Database manipulation
# To analyze the data this tool creates a temporary database using data provided by pihole-ftl.db and gravity.db
# timeout is set to 5000 ms in which sqlite tries to open an locked database
#
#
# table blocked_domains selects all domains from pihole-ftl.db that that are also found in gravity.db. Depending on -d n this is limited to the last n days (gets all domains that would have been blocked)
# table adlist copies id, enable, address from gravity.adlist
# 
# table gravity_strip selects all domains and adlist_ids from gravitiy.db for which it finds corresponding domains in blocked_domains table (strips gravity to domains which could have been blocked)
# table blacklist_gravity contains all domains that are on the blacklist and also found in an adlist (aka gravity_strip)

# table unique_domains contains all domains from gravity_strip that are found just on one adlist (covered unique domains)
# table adlist is updated with the sum of domains for each id it finds a corresponding id in gravity_strip (counts how many domains this adlist whould have covered if used alone)
# table adlist is updated with the sum of hits for all domains for each id when it finds a corresponding id in gravity_strip (counts how many hits this adlist whould have covered if used alone)
# table adlist is updated with the number of unique_domains for each adlist id (number of unique domains covered by each adlist)
# table blacklist_gravity is updated with the number of hits for each domain found in blocked_domains

sqlite3 -cmd ".timeout 5000" $TEMP_DB << EOF
    create table blocked_domains (domain TEXT,hits INTEGER);
    create table adlist (id INTEGER, enabled INTEGER, address TEXT, total_domains INTEGER, domains_covered INTEGER, hits_covered INTEGER, unique_domains_covered INTEGER);
    create table gravity_strip (domain TEXT,adlist_id INTEGER);
    create table blacklist_gravity(domain TEXT, hits INTEGER);
    create table unique_domains(domain TEXT, adlist_id INTEGER);
    
    ATTACH DATABASE "${PIHOLE_FTL}" AS pihole_ftl_db;
    ATTACH DATABASE "${GRAVITY}" AS gravity_db;

    INSERT INTO blocked_domains(domain, hits) SELECT domain, COUNT(domain) FROM pihole_ftl_db.queries WHERE EXISTS (select 1 from gravity_db.gravity where gravity.domain=queries.domain) AND id>=${FTL_ID} GROUP BY domain ORDER BY COUNT(domain) DESC;
    

    INSERT INTO adlist (id, enabled, address) SELECT id, enabled, address FROM gravity_db.adlist ORDER BY adlist.id; 
    
    INSERT INTO gravity_strip(domain,adlist_id) SELECT gravity_db.gravity.domain, gravity_db.gravity.adlist_id FROM gravity JOIN blocked_domains ON blocked_domains.domain = gravity.domain;
    INSERT INTO blacklist_gravity(domain) SELECT gravity_strip.domain FROM gravity_strip JOIN gravity_db.domainlist on gravity_strip.domain=gravity_db.domainlist.domain WHERE type==1 GROUP BY gravity_strip.domain;

    
    
    
    INSERT INTO unique_domains(domain, adlist_id) SELECT domain, adlist_id FROM gravity_strip GROUP BY domain HAVING COUNT(domain)==1 order by adlist_id asc;
    UPDATE adlist SET domains_covered=(select count(domain) FROM gravity_strip WHERE id== adlist_id GROUP BY adlist_id);
    UPDATE adlist SET hits_covered=(SELECT SUM(blocked_domains.hits) FROM gravity_strip JOIN blocked_domains ON gravity_strip.domain == blocked_domains.domain WHERE id== adlist_id Group by adlist_id);
    UPDATE adlist SET unique_domains_covered=(SELECT COUNT(domain) FROM unique_domains WHERE adlist_id==id GROUP BY adlist_id);
    UPDATE blacklist_gravity SET hits=(SELECT blocked_domains.hits FROM blocked_domains WHERE blocked_domains.domain=blacklist_gravity.domain);

    DETACH DATABASE gravity_db;
    DETACH DATABASE pihole_ftl_db;
.exit
EOF

# table adlist is updated with total number of domains for each id (adlist)
# doing this outside of the heredoc becaus external loop is faster than nestest UPDATE through whole table scan
sqlite3 -separator " " $GRAVITY "SELECT adlist_id,count(domain) FROM gravity GROUP BY adlist_id;" | while read adlist_id count; do
    sqlite3 $TEMP_DB "UPDATE adlist SET total_domains="${count}" WHERE id="${adlist_id}";"
done


# get some statistics
read NUM_DOMAINS_BLOCKED HITS_TOTAL <<<$(sqlite3 -separator " " $PIHOLE_FTL "SELECT COUNT(DISTINCT domain),count (domain) FROM queries WHERE id>=${FTL_ID} AND status == 1;")

NUM_ADLISTS=$(sqlite3 $TEMP_DB "SELECT COUNT(id) FROM adlist;")
NUM_ADLISTS_ENABLED=$(sqlite3 $TEMP_DB "SELECT COUNT(id) FROM adlist WHERE enabled==1;")
NUM_GRAVITY_UNIQUE_DOMAINS=$(sqlite3 $GRAVITY "SELECT value FROM info WHERE property == 'gravity_count';")
NUM_DOMAINS_BLOCKED_CURRENT=$(sqlite3 $TEMP_DB "SELECT COUNT(domain) FROM blocked_domains;")
HITS_TOTAL_CURRENT=$(sqlite3 $TEMP_DB "SELECT SUM(hits) FROM blocked_domains;")
BLACKLIST_GRAVITY=$(sqlite3 $TEMP_DB "SELECT COUNT(*) FROM blacklist_gravity;")
NUM_TOTAL_UNIQUE_DOMAINS=$(sqlite3 $TEMP_DB "SELECT COUNT(*) FROM unique_domains;")


echo
echo "You have ${bold}"$NUM_ADLISTS" adlists${normal} configured ("$NUM_ADLISTS_ENABLED" enabled). Your gravity.db contains ${bold}"$NUM_GRAVITY_UNIQUE_DOMAINS" unique domains${normal}."
echo
echo "Since "$DATE_FIRST_ANALYZED" ${bold}"$NUM_DOMAINS_BLOCKED" different domains${normal} from your adlists have been blocked ${bold}"$HITS_TOTAL" times${normal} in total."


echo
echo "Using you current adlist configuration ${bold}"$NUM_DOMAINS_BLOCKED_CURRENT" domains${normal} would have been blocked ${bold}"$HITS_TOTAL_CURRENT" times${normal}."
echo
echo
echo
echo
read -p "Press enter to continue..."

if [ "$BLACKLIST_GRAVITY" -ne 0 ]; then
    echo
    echo
    echo "${bold}**You hit a spececial case***${normal}" 
    echo "Your personal blacklist contains at least one domain that is also on an adlist and has been requested in the selected time period."
    echo "If pihole blocked it (because blacklist was enabled at the time of the request) it got a special status ('blocked by blacklist' instead of 'blocked by gravity')"
    echo "and is NOT counted on the above number of blocked domains/hits. As the domain is on an adlist the number of potentially blocked domains/hits is therefore is higher."
    echo
    echo
    sqlite3 -column -header $TEMP_DB "SELECT * FROM blacklist_gravity"
    echo
    echo "use 'pihole -q \"domain\"' to see on which adlist(s) it is"
    echo
    echo
    echo
    read -p "Press enter to continue..."
fi


echo
echo
# prints n top potentially blocked domains based on -t argument
if [ "$TOP" = 0 ]; then :
else
echo 
echo "${bold}*** Top blocked adlist domains ***${normal}"
echo
echo
echo "Those would  have been the ${bold}"$TOP" top blocked adlist domains${normal} since "$DATE_FIRST_ANALYZED" using your current adlist configuration"
echo
sqlite3 -column -header $TEMP_DB "SELECT domain, hits FROM blocked_domains LIMIT "${TOP}";"
echo
echo
echo
echo
read -p "Press enter to continue..."
fi
    
echo
echo

echo "${bold}*** Adlist coverage ***${normal}"
echo
echo

# prints the adlist table, sorting depends on -s argument
sqlite3 -column -header $TEMP_DB "SELECT id, enabled, total_domains, domains_covered, hits_covered, unique_domains_covered, address FROM adlist ORDER BY ${SORT_ORDER};"

echo
echo "Domains from disabled adlists are not stored in gravity's database. If you want to include them, enable them and run 'pihole -g'"
echo "As the same domains usually appears on more than one adlist the sum of covered domains from this table is greater "
echo "than the number of calculated blocked domains shown above"
echo
echo "In total your adlists contain ${bold}"$NUM_TOTAL_UNIQUE_DOMAINS" visited (covered) unique domains${normal} - meaning those domains are contained only in a single adlist. "
echo
echo

if [ "$UNIQUE" = 1 ];
    then 
        echo
        echo        
        read -p "Press enter to continue..."
        echo
        echo
        echo "${bold}***Covered unique domains ***${normal}"
        echo
        sqlite3 -column -header $TEMP_DB "SELECT domain, adlist_id, address FROM unique_domains JOIN adlist WHERE adlist_id=id;"
        echo
        echo
fi
# removes temporary database
rm $TEMP_DB

